** PROJECT TITLE: P17: SIMPLE (Yal2JVM)

** GROUP: G41

NAME1: Ricardo Wragg Freitas, NR1: 199502870
GRADE1: 13, CONTRIBUTION1: 100%



** SUMMARY:

The main purpose of this tool is to convert a yal file into a Jasmin syntax file.
Performs the basic steps of a compiler:
- Syntactic analysis
- Semantic analysis
- Code generation
- Output file generation

Outputs errors whenever applicable and aborts the compilation.



** REPOSITORY

The code is stored at https://github.com/Zehntor/comp2017



** EXECUTE:

To perform the compilation to Jasmin:
java -jar yal2jvm.jar <input-file.yal>

To compile the Jasmin file to Java bytecodes:
java -jar jasmin.jar <input-file.j>

To execute the Java bytecodes:
java <input-file>



** DEALING WITH INPUT FILE ERRORS

The application:
- Checks the number of arguments
    - If below expected, prints a usage message and aborts compilation
- Checks that the input file has a 'yal' extension
    - If not, prints a message warning about the correct extension and aborts compilation
- Checks that the file exists
    - if not, prints a message warning about the file inexistence and aborts compilation



**DEALING WITH SYNTACTIC ERRORS:

The syntatic error analysis phase is performed by the javacc generated files.
Any exceptions produced are treated, a friendly error message is printed and the compilation is aborted


**SEMANTIC ANALYSIS:

The semantic analiser implements the visitor pattern in order to visit all the AST nodes.
The semantic visitor looks at each node and uses a particular analiser according to the node type.
The particular analisers are created at a factory.
There are N analiser types:
- Module analiser
    Analises a MODULE node. Checks for:
    - Duplicate global variables
- Function analiser
    Analises a FUNCTION node. Checks for:
    - Duplicate function ids
    - Duplicate arguments
    - Correct return assignments
- Assign analiser
    Analises an ASSIGN node. Checks for:
    - Correct function calls
The semantic analiser also:
- Checks for the existence of the main function

The architecture of the semantic analysis step is well defined. More semantic analysers could have easily been added.



**INTERMEDIATE REPRESENTATIONS (IRs):

Code generation takes as input the AST and the symbol table(s) of the compiled yal module.



**CODE GENERATION:

The code generator implements the visitor pattern in order to visit all the AST nodes.
The code generator looks at each node and uses a particular generator according to the node type.
The particular generators are created at a factory.
There are N generator types:
- Assign code generator
- ExprTest code generator
- Function call code generator
- Function code generator
- If code generator
- Module code generator
- Statement code generator
- Statement list code generator
- While code generator

The architecture of the code generation step is well defined. More code generators could have easily been added.

Note: due to lack of time the code generation step is incomplete..



**OVERVIEW:

The application was split into:

Vendor files:
- All the files generated by javacc are stored in the vendor folder and should not be touched

3 main modules:
- Syntactic analiser
    - Performs the syntactic analysis step of the compilation.
      As this is performed by the vendor classes, only exceptions need to be caught and displayed in a friendly manner.
- Semantic analiser
    - Performs the semantic analysis step of the compilation.
    - As the code could grow to an unmaintainable size, and to keep the code clean and according to SOLID principles,
      a number of classes were created to deal with specific semantic rules.
      (com/comp/semantic_analyser/analisers/*)
- Code generator
    - Performs the semantic analysis step of the compilation.
    - As the code could grow to an unmaintainable size, and to keep the code clean and according to SOLID principles,
      a number of classes were created to deal with specific code generation rules.
      (com/comp/code_generator/generators/*)

2 secondary modules:
- Utilities module
    - General utilities used throughout the application
    - Node manipulation utilities
    - Jasmin utilities
- Profiler module
    - Profiles execution time and memory usage

one main file, which:
- Acts as a fa√ßade for all the compilation steps
- Performs input checks
- Displays errors

General development principles
- Modules talk to each other via services, which expose the module's functionality to the outside
- Design patterns where applicable
- No anti-patterns
- SOLID principles
- Clean code



**TESTSUITE AND TEST INFRASTRUCTURE: (Describe the content of your testsuite regarding the number of examples, the approach to automate the test, etc.)

There is a file with a syntactic error:
- syntactic_error.yal:
    - The error must be shown and the compilation aborted

There are 2 files with semantic errors:
- semantic_error_missing_main_function.yal
    - The semantic analiser must output a message stating that the main function is missing
- semantic_error_duplicates.yal
    - The semantic analiser must output 2 messages stating that:
        - There is a duplicate global variable
        - There is a duplicate function id

There are 2 files that compile without errors:
- print_global_var.yal
- test_01.yal

There is no test automation, all the tests have to be performed manually.



**TASK DISTRIBUTION:

Ricardo Wragg Freitas, NR: 199502870
    Architect
        Application overall architecture
        Module definition and contracts
        General development principles
    Developer
        Application development
        Implementation details
        Design pattern choice
    Project Manager
        Project management and tracking
        Task estimation
    Product Owner
        Translation of specifications into functional requirements
    QA engineer
        Test suite design, implementation and testing
    Release Manager
        Deliverables definition
        Deliverables preparation
        Repository maintenance
        README.txt writing



**PROS: (Identify the most positive aspects of your tool)

- Well planned
- Well structured
- Maintainable
- Extensible
- Fast



**CONS: (Identify the most negative aspects of your tool)

Does not generate all the Jasmin code correctly..