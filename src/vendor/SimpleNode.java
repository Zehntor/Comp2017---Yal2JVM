/* Generated By:JJTree: Do not edit this line. SimpleNode.java Version 4.3 */
/* JavaCCOptions:MULTI=false,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package vendor;

import java.util.List;
import java.util.ArrayList;
import com.comp.common.Visitor;
import com.comp.semantic_analyser.NodeType;


public class SimpleNode implements Node {

    protected Node parent;
    protected Node[] children;
    protected int id;
    protected Object value;
    protected Parser parser;
    protected int line;
    protected int column;

    public SimpleNode(int i) {
        id = i;
    }

    public SimpleNode(Parser p, int i) {
        this(i);
        parser = p;
    }

    public SimpleNode setValue(Object value) {
        this.value = value;
        return this;
    }

    public Object getValue() {
        return value;
    }

    @Override
    public String getValueToString() {
        return value.toString();
    }

    public SimpleNode setLine(int line) {
        this.line = line;
        return this;
    }

    public int getLine() {
        return line;
    }

    public SimpleNode setColumn(int column) {
        this.column = column;
        return this;
    }

    public int getColumn() {
        return column;
    }

    public void jjtOpen() {
    }

    public void jjtClose() {
    }

    public void jjtSetParent(Node n) {
        parent = n;
    }

    public Node jjtGetParent() {
        return parent;
    }

    public void jjtAddChild(Node n, int i) {
        if (children == null) {
            children = new Node[i + 1];
        } else if (i >= children.length) {
            Node c[] = new Node[i + 1];
            System.arraycopy(children, 0, c, 0, children.length);
            children = c;
        }
        children[i] = n;
    }

    public Node jjtGetChild(int i) {
        return children[i];
    }

    public int jjtGetNumChildren() {
        return (children == null) ? 0 : children.length;
    }

    public void jjtSetValue(Object value) {
        this.value = value;
    }

    public Object jjtGetValue() {
        return value;
    }

    public void accept(Visitor visitor) {
        visitor.visit(this);
        for (int n = 0; n < jjtGetNumChildren(); n++) {
            jjtGetChild(n).accept(visitor);
        }
    }

  /* You can override these two methods in subclasses of SimpleNode to
     customize the way the node appears when the tree is dumped.  If
     your output uses more than one line you should override
     toString(String), otherwise overriding toString() is probably all
     you need to do. */

    public String toString() {
        return ParserTreeConstants.jjtNodeName[id];
    }

    public String toString(String prefix) {
        return prefix + toString();
    }

  /* Override this method if you want to customize how the node dumps
     out its children. */

    public void dump(String prefix) {
        System.out.println(toString(prefix));
        if (children != null) {
            for (int i = 0; i < children.length; ++i) {
                SimpleNode n = (SimpleNode) children[i];
                if (n != null) {
                    n.dump(prefix + " ");
                }
            }
        }
    }

    /**
     * Customs methods below
     */

    /**
     * Gets the value, the begin line and the begin column from the token
     * @param token
     * @return SimpleNode, for a fluent interface
     */
    public SimpleNode getInfoFromToken(Token token) {
        value  = token.image;
        line   = token.beginLine;
        column = token.beginColumn;

        return this;
    }

    /**
     * Returns true if the node has children; false otherwise
     * @return boolean
     */
    @Override
    public boolean hasChildren() {
        return children.length > 0;
    }

    /**
     * Finds and returns the first child which is of the specified type
     * @param type
     * @return Node
     */
    @Override
    public Node getChildOfType(NodeType type) {
        for (int n = 0; n < jjtGetNumChildren(); n++) {
            if (NodeType.fromString(jjtGetChild(n).toString()) == type) {
                return jjtGetChild(n);
            }
        }

        return null;
    }

    /**
     * Finds and returns a list of children which are of the specified type
     * @param type
     * @return List<Node>
     */
    @Override
    public List<Node> getChildrenOfType(NodeType type) {
        List<Node> children = new ArrayList<>();

        for (int n = 0; n < jjtGetNumChildren(); n++) {
            if (NodeType.fromString(jjtGetChild(n).toString()) == type) {
                children.add(jjtGetChild(n));
            }
        }

        return children;
    }

    /**
     * Returns true if the node has at least one child of the specified type; false otherwise
     * @param type
     * @return boolean
     */
    @Override
    public boolean hasChildOfType(NodeType type) {
        return getChildOfType(type) != null;
    }

    /**
     * Returns true if the node is of the specified type; false otherwise
     * @param type
     * @return
     */
    @Override
    public boolean isOfType(NodeType type) {
        return NodeType.fromString(toString()) == type;
    }

    /**
     * Return the first (counting bottom up) ancestor of the specified type
     * @param type
     * @return Node the ancestor, or null if not found
     */
    @Override
    public Node getAncestorOfType(NodeType type) {
        if (jjtGetParent() == null) {
            return null;
        }

        if (jjtGetParent().isOfType(type)) {
            return jjtGetParent();
        }

        return jjtGetParent().getAncestorOfType(type);
    }

    /**
     * Finds and returns the first sibling which is of the specified type
     * @param type
     * @return Node
     */
    @Override
    public Node getSiblingOfType(NodeType type) {
        if (jjtGetParent() == null) {
            return null;
        }

        return jjtGetParent().getChildOfType(type);
    }

    /**
     * Returns true if the node has an ancestor of the specified type; false otherwise
     * @param type
     * @return
     */
    @Override
    public boolean hasSiblingOfType(NodeType type) {
        return getSiblingOfType(type) != null;
    }

    /**
     * Returns true if the node has an ancestor of the specified type; false otherwise
     * @param type
     * @return
     */
    @Override
    public boolean hasAncestorOfType(NodeType type) {
        return getAncestorOfType(type) != null;
    }
}

/* JavaCC - OriginalChecksum=b5c742072ec3bac3d20a0c60db1563d3 (do not edit this line) */
